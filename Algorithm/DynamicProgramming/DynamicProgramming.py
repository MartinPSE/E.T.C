# 다이나믹 프로그래밍
# '메모리를 적절히 사용하여' 수행 시간 효율성을 비약적으로 향상시키는 방법.
# '이미 계산된 결과는 별도의 메모리 영역'에 저장하여 다시 계산하지 앟도록 한다.
# 다이나믹 프로그래밍의 구현은 일반적으로 2가지 방식 (탑다운, 보텀업)으로 구성된다.

# '동적 계획법'이라고도 부른다.
# 일반적인 프로그래밍 분야에서의 동적(Dynamic) 이란?
"""
자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실해오디는 도중에 실행에 필요한 메모리를 할당하는 기법'
"""
# 반면에 다이나믹 프로그래밍에서 '다이나믹'은 "별다른 의미 없이 사용된 단어"

"""
idea 1. 최적 부분 구조 (Optimal Substructure)
        - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있다.
idea 2. 중복되는 부분 문제 (Overlapping Subproblem)
        - 동일한 작은 문제를 반복적으로 해결 
"""


# 피보나치 수열
def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)


print(fibonacci(4))

# 하향식 즉 업다운 방식
"""
메모이제이션 (Memoization)
-> 한번 계산한 결과를 메모리 공간에 메모 하는 기법
    : 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져오자
    : 값을 기록해 놓는다는 점에서 캐싱(Cashing)이라고도 한다.
-> 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
    : 다이나믹 프로그래밍에 국한된 개념이 아니다!
    : 계산된 결과 담아놓고 --> 다이나믹 프로그래밍에 활용 안 할 수도 있어.
"""

# 전형적인 형태는 '보텀업'방식이다.
# 결과 저장용 리스트는 DP 테이블 이라고 부른다.

# 피보나치 수열 : 탑다운 다이나믹 프로그래밍 소스코드!

d = [0] * 100


# 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
def fibo(x):
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라 재귀
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]


print(fibo(99))

# 보텀업 방식 다이나믹 프로그래밍

e = [0] * 100
e[1] = 1
e[2] = 1
n = 99

for i in range(3, n+1):
    e[i] = e[i-1] + e[i-2]

print(e[n])
